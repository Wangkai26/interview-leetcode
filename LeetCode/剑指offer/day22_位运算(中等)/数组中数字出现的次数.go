//题目链接：https://leetcode.cn/problems/shu-zu-zhong-shu-zi-chu-xian-de-ci-shu-lcof/
// day22/31
// 第 22 天主题为：位运算（中等）
// 包含两道题目：
// 剑指offer56.数组中数字出现的次数
// 剑指offer56-II.数组中数字出现的次数 II
package main

//本题最通俗的解法是哈希表记录每个数字出现的次数，不符合题目要求空间复杂度，位运算解法可将空间复杂度从 O(n) 降低至 O(1)
//解题思路：分组异或
//先考虑一种简单的情况，一个整形数组 nums 中除一个数字出现一次之外，其余数字都出现了两次，找出这个数字。
//很容易想到用 异或 来解决。两个相同的数字进行异或操作结果为 0。对 nums 进行一次遍历，xor 变量初始化为 0
//与 nums 中每个数字进行异或操作，相同的数字会两两抵消，最后 xor 就与仅出现一次的数字值相同。
//
//回到本题，有两个出现一次的数字，设为 a 和 b，如果我们使用相同的方法对 nums 进行异或，最终得到的结果 xor 会是 a 与 b 异或的结果。
//xor 必定不等于 0，因为若 xor 等于 0，说明 a==b，与条件相悖。

//我们可以根据 xor 的二进制中任意不等于 0 的位进行分组，将 a 和 b 分到不同的组中，然后对两组数字分别进行异或，取出 a 和 b。
//假设 xor 的第二位为 1，那我们就取 x = 10，对 nums 进行遍历，记当前数字为 num，根据 num&x==0和 num&x!=0 分组，
//a 和 b 在各自组中异或得到。

// 简单一句话描述：
//先对所有数字进行异或操作，得到两个只出现一次的数字进行异或的结果，在该结果中找到任意为 1 的位，
//根据该位对所有数字进行分组，在每个组内进行异或操作，即可得到两个数字。
func singleNumbers(nums []int) []int {
	xor := 0
	for _,num := range nums{
		xor ^= num
	}
	x := 1
	for {
		if xor & x == 0{
			x <<= 1
		} else {
			break
		}
	}
	a,b := 0,0
	for _,num := range nums{
		if num & x == 0{
			a ^= num
		} else {
			b ^= num
		}
	}
	return []int{a,b}
}