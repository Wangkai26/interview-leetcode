//题目链接：https://leetcode.cn/problems/er-cha-sou-suo-shu-de-hou-xu-bian-li-xu-lie-lcof/
// day20/31
// 第 20 天主题为：分治算法（中等）
// 包含三道题目：
// 剑指offer07.重建二叉树
// 剑指offer16.数值的整数次方
// 剑指offer33.二叉搜索树的后序遍历序列

package main

//一句话描述：后序遍历的根节点在最后一位，前面可以分为两部分，一部分为左子树的后序遍历，另一部分为右子树的后序遍历，
//右子树所有节点值均大于根节点，找到右子树节点的起始节点，判断该部分是否所有节点值都大于根节点的值，
//若否，说明该序列无法构成BST的后序遍历序列，之后再递归判断左子树部分和右子树部分的序列是否为BST的后序遍历序列。
//
//下面是详细描述：
//二叉树后序遍历的结果是：[ [左子树的后序遍历结果], [右子树的后序遍历结果]，根节点]
//我们可以把后序遍历数组分为三部分：左子树的后序遍历、右子树的后序遍历和该二叉树的根节点。二叉树的根节点一定是后序遍历数组的最后一个元素。
//BST左子树所有元素节点值均小于根节点，右子树所有元素值均大于根节点。所以，我们可以从后序遍历数组的第一个元素遍历到倒数第二个元素，
//进行判断，是否大于等于根节点，若大于等于，说明该元素之前所有元素为左子树的后序遍历结果，从该元素至倒数第二个元素为右子树的后序遍历结果。
//从该元素起，遍历到倒数第二个元素，若存在元素值小于根节点的值，说明该数组不是BST的后序遍历序列。 然后递归地判断左子树序列与右子树序列是否为某BST的后序遍历序列。
//
//有一点需要注意的是，right的初始化应该是序列长度-1，我刚开始初始化为0，结果就出错了。
//如果将 k 初始化为 0，且右子树区间大小为 0，最后 k 值为 0,递归验证右子树的区间会是 postorder[0:n-1]，
//而实际上该区间大小为 0,所以我们初始化 k 时，需要其值 大于等于 n-1。
//这是容易出错的一个点，需要牢记

func verifyPostorder(postorder []int) bool {
	// 若数组大小小于等于2，则必定是某BST的后序遍历序列
	if len(postorder) <= 2{
		return true
	}
	n := len(postorder)
	// 后序遍历的根节点在数组最后一位
	root := postorder[n-1]
	// k 为右子树的后序遍历序列起始下标
	// 初始化为 n-1
	k := n-1
	// 寻找 k 值
	for i:=0;i < n-1;i++{
		if postorder[i] > root{
			k = i
			break
		}
	}
	// 验证根节点的右子树所有节点值均大于根节点值
	// 若存在小于根节点的节点，返回 false
	for i:=k+1;i<n;i++{
		if postorder[i] < root{
			return false
		}
	}
	// 验证左子树的后序遍历序列
	left := verifyPostorder(postorder[:k])
	// 验证右子树的后序遍历序列
	right := verifyPostorder(postorder[k:n-1])
	return left && right
}